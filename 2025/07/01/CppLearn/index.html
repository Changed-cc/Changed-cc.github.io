<!DOCTYPE html>
<html lang="zh-CN">
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="John Doe" />



<meta name="description" content="@TOC 注意：以下是ACWing课程学习笔记，若有侵权联系我删除文章 学习步骤：语法基础课-算法基础课-算法提高课-算法进阶课  AC Saber软件练习，思维导图 基础语法  1. 入门123456789101112#include &lt;iostream&gt;      &#x2F;&#x2F;包含cin和cout#includev &lt;iomanip&gt;        &#x2F;&#x2F;c++中输出时可以保持精">
<meta property="og:type" content="article">
<meta property="og:title" content="蓝桥杯准备-C++">
<meta property="og:url" content="http://example.com/2025/07/01/CppLearn/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="@TOC 注意：以下是ACWing课程学习笔记，若有侵权联系我删除文章 学习步骤：语法基础课-算法基础课-算法提高课-算法进阶课  AC Saber软件练习，思维导图 基础语法  1. 入门123456789101112#include &lt;iostream&gt;      &#x2F;&#x2F;包含cin和cout#includev &lt;iomanip&gt;        &#x2F;&#x2F;c++中输出时可以保持精">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i-blog.csdnimg.cn/direct/1759567ccd794b168f0243c10dd809a9.png">
<meta property="og:image" content="https://i-blog.csdnimg.cn/direct/5d5c6025e22447ce9251f9c53cdb45c6.png">
<meta property="og:image" content="https://i-blog.csdnimg.cn/direct/24696acd1595470d969e4316e73d4a82.png">
<meta property="og:image" content="https://i-blog.csdnimg.cn/direct/205817f77056425bb09c916eb0511d8c.png">
<meta property="og:image" content="https://i-blog.csdnimg.cn/direct/a3ea596e097b48dbb99804c2cd3a86d7.png">
<meta property="og:image" content="https://i-blog.csdnimg.cn/direct/f5576c8e29b94741933e37a617cbc788.png">
<meta property="og:image" content="https://i-blog.csdnimg.cn/direct/5c3ee2bb00d9424e8f8a7a9cb96690d8.png">
<meta property="og:image" content="https://i-blog.csdnimg.cn/direct/17d2d3fc63124bc89371fb469fb74f16.png">
<meta property="og:image" content="https://i-blog.csdnimg.cn/direct/2f8739ae99364aed804164b33e4c49f8.png">
<meta property="og:image" content="https://i-blog.csdnimg.cn/direct/6e63b20d49a54247bcd50b318baeb2c9.png">
<meta property="og:image" content="https://i-blog.csdnimg.cn/direct/d9fbb32f908f452894d446a0e95f971c.png">
<meta property="og:image" content="https://i-blog.csdnimg.cn/direct/8d319e822cea4cbfa54d786ca1f2883b.png">
<meta property="og:image" content="https://i-blog.csdnimg.cn/direct/44b6b6c960b548c98d1b45ea43485fff.png">
<meta property="og:image" content="https://i-blog.csdnimg.cn/direct/77a6a82ad3d640f08b810d491351bdcd.png">
<meta property="og:image" content="https://i-blog.csdnimg.cn/direct/303a1a8fe9174549b398869e639d1c63.png">
<meta property="og:image" content="https://i-blog.csdnimg.cn/direct/3d2c7f52237b45c98ddbe4d528cd5caa.png">
<meta property="og:image" content="https://i-blog.csdnimg.cn/direct/5abd290e48f54ac9b24cd43dbf436847.png">
<meta property="article:published_time" content="2025-06-30T16:00:00.000Z">
<meta property="article:modified_time" content="2025-07-10T05:11:40.304Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i-blog.csdnimg.cn/direct/1759567ccd794b168f0243c10dd809a9.png">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">



<link rel="stylesheet" href="/css/style.css">




<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>蓝桥杯准备-C++ | Hexo</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: 
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






<meta name="generator" content="Hexo 6.3.0"></head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/"></a></h1>
        </hgroup>

        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">首页</a></li>
                        
                            <li><a href="/study/">学习笔记</a></li>
                        
                            <li><a href="/resources/">学习资料</a></li>
                        
                            <li><a href="/photos/">摄影集</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="/2459664552@qq.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" rel="noopener" href="https://github.com/Changed-cc?tab=repositories" title="GitHub"></a>
                            
                                <a class="fa RSS" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" target="_blank" rel="noopener" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" target="_blank" rel="noopener" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" target="_blank" rel="noopener" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">专注于前端</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页"></a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页"></a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">首页</a></li>
                
                    <li><a href="/study/">学习笔记</a></li>
                
                    <li><a href="/resources/">学习资料</a></li>
                
                    <li><a href="/photos/">摄影集</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="/2459664552@qq.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/Changed-cc?tab=repositories" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap"><article id="post-CppLearn" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2025/07/01/CppLearn/" class="article-date">
      <time datetime="2025-06-30T16:00:00.000Z" itemprop="datePublished">2025年07月01日</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      蓝桥杯准备-C++
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/study/">study</a>
    </div>


        
        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>@<a href="%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%87%86%E5%A4%87-C++">TOC</a></p>
<h1 id="注意：以下是ACWing课程学习笔记，若有侵权联系我删除文章"><a href="#注意：以下是ACWing课程学习笔记，若有侵权联系我删除文章" class="headerlink" title="注意：以下是ACWing课程学习笔记，若有侵权联系我删除文章"></a><strong>注意：以下是ACWing课程学习笔记，若有侵权联系我删除文章</strong></h1><p> 学习步骤：语法基础课-算法基础课-算法提高课-算法进阶课</p>
<ul>
<li><p>AC Saber软件练习，思维导图</p>
<h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2></li>
</ul>
<h3 id="1-入门"><a href="#1-入门" class="headerlink" title="1. 入门"></a>1. 入门</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>      <span class="comment">//包含cin和cout</span></span></span><br><span class="line"><span class="meta">#includev <span class="string">&lt;iomanip&gt;</span>        <span class="comment">//c++中输出时可以保持精度</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span>        <span class="comment">//包含printf和scanf函数</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>                <span class="comment">//函数入口</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>) &lt;&lt; a + b  &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello,World!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>命名空间问题</strong>：cin 和 cout 需要使用 std:: 命名空间，或者你可以在文件开头使用 using namespace std; 来避免每次都加 std::。<br><strong>选择什么输入输出函数</strong>：<br>cout输出时使用字符串拼接比较麻烦，使用scanf和printf比较方便；<br>cin和cout相较于scanf和printf代码运行速度会变慢，运行时间会变长；<br><strong>c++万能头文件</strong>：<code>#include &lt;bits/stdc++.h&gt;</code></p>
<h3 id="2-变量"><a href="#2-变量" class="headerlink" title="2. 变量"></a>2. 变量</h3><ol>
<li>先定义再使用</li>
<li>定义为全局变量时初值为0，定义为局部变量时初值为随机值</li>
</ol>
<h3 id="3-变量类型-5种基本数据类型"><a href="#3-变量类型-5种基本数据类型" class="headerlink" title="3. 变量类型(5种基本数据类型)"></a>3. 变量类型(5种基本数据类型)</h3><table>
<thead>
<tr>
<th>变量类型</th>
<th>名称</th>
<th>举例</th>
<th>输出格式</th>
</tr>
</thead>
<tbody><tr>
<td>bool</td>
<td>布尔型</td>
<td>true&#x2F;false</td>
<td>无</td>
</tr>
<tr>
<td>char</td>
<td>字符型</td>
<td>‘c’</td>
<td>%c</td>
</tr>
<tr>
<td>int</td>
<td>整数型</td>
<td>8</td>
<td>%d</td>
</tr>
<tr>
<td>float</td>
<td>浮点型</td>
<td>8.0000</td>
<td>%f</td>
</tr>
<tr>
<td>double</td>
<td>双浮点型</td>
<td>8.00</td>
<td>%lf</td>
</tr>
</tbody></table>
<p><strong>注</strong>: <strong>string</strong> 类是C++标准库中用于处理字符串的类，它提供了一系列用于字符串操作的方法，如赋值、连接、查找、替换等</p>
<h3 id="4-表达式（加减乘除）和运算符"><a href="#4-表达式（加减乘除）和运算符" class="headerlink" title="4.表达式（加减乘除）和运算符"></a>4.表达式（加减乘除）和运算符</h3><h3 id="5-C-中的判断结构"><a href="#5-C-中的判断结构" class="headerlink" title="5.C++中的判断结构"></a>5.C++中的判断结构</h3><ul>
<li><strong>if条件语句</strong>：if-else；if；</li>
<li><strong>while循环语句</strong> || <strong>for循环语句</strong>：区分do while和while，do while至少执行一次循环</li>
<li><strong>swich选择语句</strong></li>
<li><strong>break和continue跳转语句</strong>：break跳出循环，而continue跳出本次循环</li>
</ul>
<h3 id="6-C-中的数组"><a href="#6-C-中的数组" class="headerlink" title="6.C++中的数组"></a>6.C++中的数组</h3><ul>
<li>一维数组：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>多维数组</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> b[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;,</span><br><span class="line">    &#123;<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-字符串"><a href="#7-字符串" class="headerlink" title="7.字符串"></a>7.字符串</h3><ul>
<li>ASCII码：<code>‘A’-‘Z’</code> 是65~90，<code>’a’-‘z’</code>是97-122，<code>’0’-‘9’</code>是48-57</li>
<li>字符串的定义：字符数组加上结束符<code>&#39;\0&#39;</code></li>
<li>头文件：<code>#include&lt;string.h&gt;</code>引入字符数组的操作；<code>#include&lt;string&gt;</code>引入可变长的字符序列</li>
<li><strong>字符数组</strong>常用操作<br><code>strlen(str)</code>求字符串的长度<br><code>strcmp(a,b)</code>比较两个字符串的大小，a&lt;b则return -1，a&#x3D;&#x3D;b则return1<br><code>循环遍历字符串</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a[<span class="number">100</span>] = <span class="string">&quot;hello world!&quot;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(a);i++)&#123;</span><br><span class="line">    cout&lt;&lt;a[i]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>字符序列</strong>操作</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s1,s2;</span><br><span class="line">    cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">    cout &lt;&lt; s1 &lt;&lt; s2 &lt;&lt;endl;</span><br><span class="line">    string s3;</span><br><span class="line">    <span class="built_in">getline</span>(cin,s);<span class="comment">//读取一整行</span></span><br><span class="line">    cout &gt;&gt; s &gt;&gt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>s1.empty()</code>:测试变量是否配置<br><code>s1.size()</code>:获取字符串长度，size是无符号整数， 因此s.size() &lt;&#x3D; -1一定成立<br><code>两个string对象相加</code>:实现了字符串拼接<br><code>字面值和string对象相加</code>:字面值和字符都会被转化成string对象</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误的写法</span></span><br><span class="line">string s7 = “hello” + “, “ + s2;</span><br><span class="line"><span class="comment">//正确的写法</span></span><br><span class="line">string s6 = s1 + “, “ + “world”;</span><br><span class="line"><span class="comment">//总结：运算对象至少有一个运算符是string对象</span></span><br></pre></td></tr></table></figure>

<ul>
<li>不忽略空格求长度的两种写法<br>注：<code>cin</code>和<code>printf</code>遇到空格符就停止读取了</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">gets</span>(s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in">strlen</span>(s));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>gets()函数</code>：<strong>从输入缓冲区中读取一个字符串存储到字符指针变量 str 所指向的内存空间。</strong> cin.get()不会把换行符取出来！会影响下次读入</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string a;</span><br><span class="line">    <span class="built_in">getline</span>(cin,a);</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>getline()函数</code>：<strong>主要用于从输入流中读取一行文本并将其存储为字符串。这个函数非常适合用于读取用户输入或从文件中逐行读取数据。</strong> cin.getline()会把最后的换行符取出来并删掉</p>
<p><code>find()函数和rfind()函数</code>：find函数是正向查找，rfind函数是反向查找也就是从右侧开始查找。</p>
<h3 id="8-函数"><a href="#8-函数" class="headerlink" title="8.函数"></a>8.函数</h3><ul>
<li>典型的函数定义：包括返回类型，函数名，零个或多个形参以及函数体</li>
<li>函数的调用：<br>一、用实参初始化函数对应的形参<br>二、主函数执行中断，被调函数开始执行，控制权转移给被调用函数</li>
<li>函数的位置：C&#x2F;C++中，在调用的函数前声明函数</li>
<li>形参和实参：<br>一、形参和实参的类型和个数必须匹配<br>二、形参也可以设置默认值，但所有默认值必须是最后几个。当传入的实参个数少于形参个数时，最后没有被传入值的形参会使用默认值。<br>三、形参列表可以为空但不能省略</li>
<li><strong>函数的返回类型</strong>：<br>函数的返回类型不能是数组类型或函数类型，但可以是指向数组或者函数的指针</li>
<li>参数传递<br>分为<strong>传值参数</strong>和<strong>传引用参数</strong>，传值参数仅仅是拷贝，对变量的改动不会影响初始值；传引用参数对形参的修改会影响实参的值</li>
<li>数组的形参的写法</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三种写法的函数是等价的</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> *a)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> a[])</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> a[<span class="number">10</span>])</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//多维数组,除了第一维，其他维度的大小必须指定</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> (*a)[<span class="number">10</span>])</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> a[][<span class="number">10</span>])</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> a[<span class="number">10</span>][<span class="number">10</span>])</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数递归：常见的有阶乘的求解，斐波拉契数列求解等</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fact</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//明确终止条件</span></span><br><span class="line">    <span class="keyword">return</span> n*<span class="built_in">fact</span>(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-类、结构体、指针、引用"><a href="#9-类、结构体、指针、引用" class="headerlink" title="9.类、结构体、指针、引用"></a>9.类、结构体、指针、引用</h3><ul>
<li>类的定义：成员变量包括类中的变量和函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> age,height;</span><br><span class="line">        <span class="type">double</span> money;</span><br><span class="line">        string books[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        string name;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">say</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;I&#x27;m&quot;</span> &lt;&lt; name &lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> age,height;</span><br><span class="line">        <span class="type">double</span> money;</span><br><span class="line">        string books[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        string name;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">say</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;I&#x27;m&quot;</span> &lt;&lt; name &lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;person_a,person_b,persons[<span class="number">100</span>];</span><br></pre></td></tr></table></figure>

<p>结构体和类的作用是一样的。不同点在于<strong>类默认是private，结构体默认是public。</strong></p>
<ul>
<li>指针和引用:<br>指针指向<strong>存放</strong>变量的值的<strong>地址</strong>。因此我们可以通过指针来修改变量的值。数组名是一种特殊的指针；引用和指针类似，相当于给变量起了个别名</li>
<li>链表(一种数据结构)：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    Node *next;<span class="comment">//定义一个指针</span></span><br><span class="line">&#125;*head;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建一个单链表并将数字从 1 到 5 依次插入到链表的头部</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">//创建了一个新的 Node 对象并将其地址赋值给指针 p</span></span><br><span class="line">        Node *p = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">        p-&gt;val = i;</span><br><span class="line">    <span class="comment">//当前节点的 next 指针指向链表的当前头节点 head。</span></span><br><span class="line">    <span class="comment">//也就是说，每次插入新节点时，新的节点的 next 指针指向当前链表的第一个节点。</span></span><br><span class="line">        p-&gt;next = head;</span><br><span class="line">    <span class="comment">//将 head 更新为当前节点 p。这样，head 始终指向链表的头部（新插入的节点）。通过这行代码，新的节点被插入到了链表的最前面。</span></span><br><span class="line">        head = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(Node *p = head;p;p=p-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; p-&gt;val &lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-STL"><a href="#10-STL" class="headerlink" title="10.STL"></a>10.STL</h3><ul>
<li><code>#include&lt;vector&gt;</code>:变长数组，支持随机访问，元素的增删一般在末尾进行</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a;<span class="comment">//一维数组</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;b[<span class="number">233</span>];<span class="comment">//二维数组</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">rec</span>&#123;&#125;;</span><br><span class="line">vector&lt;rec&gt; c;</span><br></pre></td></tr></table></figure>

<p>一、size函数返回数组的实际长度，empty函数返回数组是否为空，clear函数将vector函数清空<br>二、迭代器<br>迭代器就像STL容器的“指针”，可以用星号“*”操作符解除引用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it;</span><br></pre></td></tr></table></figure>

<p>三、begin函数返回指向vector中第一个元素的迭代器，因为容器是前闭后开的结构，所以<code>*a.end()</code>和<code>a[n]</code>都是越界访问，如果要找vector的最后一个元素，则应该是<code>*a.end()-1</code><br>四、front函数返回vector的第一个元素，等价于<code>*a.begin()</code> 和 <code>a[0]</code>；back函数返回vector的最后一个元素，等价于<code>*==a.end()</code> 和 <code>a[a.size() – 1]。</code><br>五、<code>a.push_back(x)</code> 把元素x插入到vector a的尾部；<code>b.pop_back()</code> 删除vector a的最后一个元素。</p>
<ul>
<li><p><code>#include&lt;queue&gt;</code>:包括循环队列queue和优先队列priority_queue两个容器</p>
</li>
<li><p><code>#include&lt;stack&gt;</code>:包含栈</p>
</li>
<li><p><code>#include&lt;deque&gt;</code>:实现双端队列</p>
</li>
<li><p><code>#include&lt;set&gt;</code>:实现有序集合和有序多重集合</p>
</li>
<li><p><code>#include&lt;map&gt;</code>：实现键值对的映射</p>
<h3 id="11-位运算与常用库函数"><a href="#11-位运算与常用库函数" class="headerlink" title="11.位运算与常用库函数"></a>11.位运算与常用库函数</h3></li>
<li><p>常用库函数<br>（1）reverse 翻转<br>（2）unique 去重<br>（3）random_shuffle 随机打乱<br>（4）sort 实现快速排序<br>（5）lower_bound&#x2F;upper_bound 实现二分</p>
</li>
</ul>
<h3 id="12-auto写法"><a href="#12-auto写法" class="headerlink" title="12.auto写法"></a>12.auto写法</h3><p>注：C++11 引入的 <strong>范围-based for 循环</strong>（Range-based for loop），用 auto 关键字来自动推导变量类型，让代码更简洁、优雅。<br><strong>作用</strong>：用于遍历容器（如 vector, array, map 等）的元素，自动处理索引，写法更简洁。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一般写法</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; H = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; H.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    cout &lt;&lt; H[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//简洁写法（不修改元素）</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x : H) &#123;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//修改元素，对原元素操作</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : H) &#123;</span><br><span class="line">    x += <span class="number">1</span>; <span class="comment">// 直接修改 H 中的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h2><h3 id="一、基本"><a href="#一、基本" class="headerlink" title="一、基本"></a>一、基本</h3><h4 id="1-高精度"><a href="#1-高精度" class="headerlink" title="1.高精度"></a>1.高精度</h4><ul>
<li>如何存储大整数？<br>利用数组存储每个位数，第0位存储个位数，最高位存储最后一位数，这样方便相加</li>
<li>C++如何使用cin和cout保留精度</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span> <span class="comment">//引入头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14159</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> R=<span class="number">0.00</span>;</span><br><span class="line">    cin &gt;&gt; R;</span><br><span class="line">    <span class="type">double</span> A=<span class="number">0.00</span>;</span><br><span class="line">    A = PI*R*R;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;A=&quot;</span> &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">4</span>)&lt;&lt; A &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二、搜索算法"><a href="#二、搜索算法" class="headerlink" title="二、搜索算法"></a>二、搜索算法</h3><h4 id="1-DFS-深度优先算法（递归或栈实现）"><a href="#1-DFS-深度优先算法（递归或栈实现）" class="headerlink" title="1. DFS-深度优先算法（递归或栈实现）"></a>1. DFS-深度优先算法（递归或栈实现）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> visited[MAXVEX];<span class="comment">//访问标记数组，记录被访问的值</span></span><br><span class="line"> <span class="comment">//深度优先搜索，访问某个顶点 </span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(MGraph *G,<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">     cout &lt;&lt; G-&gt;vexs[i] &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//访问当前节点</span></span><br><span class="line">    visited[i] = <span class="literal">true</span>; <span class="comment">//标记已访问</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j&lt;G-&gt;numVertexes;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(G-&gt;arc[i][j] != INFINITY &amp;&amp; !visited[j])&#123;<span class="comment">//访问当前顶点的邻接点 </span></span><br><span class="line">            <span class="built_in">DFS</span>(G,j); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">DFSTraverse</span><span class="params">(MGraph *G)</span></span>&#123;</span><br><span class="line">     <span class="built_in">memset</span>(visited,<span class="literal">false</span>,<span class="built_in">sizeof</span>(visited));</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;G-&gt;numVertexes;i++)&#123;</span><br><span class="line">         <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">             <span class="built_in">DFS</span>(G,i);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>

<h4 id="2-BFS-广度优先算法（队列实现）"><a href="#2-BFS-广度优先算法（队列实现）" class="headerlink" title="2.BFS-广度优先算法（队列实现）"></a>2.BFS-广度优先算法（队列实现）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//广度优先搜索 </span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(MGraph *G,<span class="type">int</span> start)</span></span>&#123;</span><br><span class="line">     <span class="built_in">memset</span>(visited,<span class="literal">false</span>,<span class="built_in">sizeof</span>(visited));</span><br><span class="line">     queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    cout &lt;&lt; G-&gt;vexs[start] &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//访问起点</span></span><br><span class="line">    visited[start]  = <span class="literal">true</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(start);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> i = q.<span class="built_in">front</span>();<span class="comment">//取队首</span></span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">//这一步相当于将当前顶点的所有邻接点全部入队 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;G-&gt;numVertexes;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(G-&gt;arc[i][j] != INFINITY &amp;&amp; !visited[j])&#123;</span><br><span class="line">                cout &lt;&lt; G-&gt;vexs[j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">                visited[j] = <span class="literal">true</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(j);<span class="comment">//入队 </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">BFSTraverse</span><span class="params">(MGraph *G)</span></span>&#123;</span><br><span class="line">     <span class="built_in">memset</span>(visited,<span class="literal">false</span>,<span class="built_in">sizeof</span>(visited));</span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;G-&gt;numVertexes;i++)&#123;</span><br><span class="line">         <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">             <span class="built_in">BFS</span>(G,i);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>

<h3 id="三、排序算法"><a href="#三、排序算法" class="headerlink" title="三、排序算法"></a>三、排序算法</h3><p>main函数测试</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">6</span>] = &#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="comment">//    InsertSort(a,6);</span></span><br><span class="line"><span class="comment">//    BubbleSort(a,6);</span></span><br><span class="line"><span class="comment">//    QuickSort(a,0,5);</span></span><br><span class="line"><span class="comment">//    ShellSort(a,6);</span></span><br><span class="line"><span class="comment">//    MergeSort(a,0,5);</span></span><br><span class="line">    <span class="built_in">heapSort</span>(a,<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-插入排序"><a href="#1-插入排序" class="headerlink" title="1.插入排序"></a>1.插入排序</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递增排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,temp;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i] &lt; A[i<span class="number">-1</span>])&#123;</span><br><span class="line">            temp = A[i];</span><br><span class="line">            <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span> &amp;&amp; A[j]&gt;temp;--j)&#123;</span><br><span class="line">                A[j<span class="number">+1</span>]=A[j];<span class="comment">//数组元素右移</span></span><br><span class="line">            &#125;</span><br><span class="line">            A[j<span class="number">+1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="希尔排序（Shell-Sort）-插入排序的优化版"><a href="#希尔排序（Shell-Sort）-插入排序的优化版" class="headerlink" title="希尔排序（Shell Sort）-插入排序的优化版"></a>希尔排序（Shell Sort）-插入排序的优化版</h4><p>核心思想：</p>
<ol>
<li>选择一个<strong>步长 gap</strong>（一般取 gap &#x3D; n&#x2F;2，然后 gap &#x2F;&#x3D; 2 递减）</li>
<li>以gap 为间隔，对相隔 gap 的元素进行插入排序，使得数组逐渐趋于有序。</li>
<li>当 gap 变为 1 时，使用标准插入排序进行最终排序。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> gap = n/<span class="number">2</span> ; gap &gt; <span class="number">0</span> ; gap /= <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = gap ;i&lt;n ;i++)&#123;</span><br><span class="line">            <span class="type">int</span> temp = arr[i],j;</span><br><span class="line">            <span class="keyword">for</span>(j=i; j&gt;= gap &amp;&amp; arr[j-gap] &gt; temp ; j-= gap)&#123;</span><br><span class="line">                arr[j] = arr[j-gap];</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-冒泡排序"><a href="#2-冒泡排序" class="headerlink" title="2.冒泡排序"></a>2.冒泡排序</h4><p>重点在于<strong>相邻元素比较后交换</strong><br><strong>外循环</strong>：一共有n-1轮<br><strong>内循环</strong>：<code>j = n - 1</code>表示从数组的最后一个元素开始遍历；<code>j &gt; i</code>表示只排序没有排序的部分</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp;a,<span class="type">int</span>&amp;b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = n<span class="number">-1</span>;j&gt;i;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[j<span class="number">-1</span>]&gt;A[j])&#123;</span><br><span class="line">                <span class="built_in">swap</span>(A[j<span class="number">-1</span>],A[j]);</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag ==<span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-快速排序"><a href="#3-快速排序" class="headerlink" title="3.快速排序"></a>3.快速排序</h4><p>思想：一个<strong>基准元素</strong>将整个数组<strong>划分</strong>成两个子数组，然后<strong>递归</strong>地对这两个子数组进行排序；基准元素一般选择首元素<br><img src="https://i-blog.csdnimg.cn/direct/1759567ccd794b168f0243c10dd809a9.png" alt="在这里插入图片描述"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp;a,<span class="type">int</span>&amp;b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//划分 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> low,<span class="type">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot = arr[high];<span class="comment">//最后一个作为基准元素 </span></span><br><span class="line">    <span class="type">int</span> i = low <span class="number">-1</span>;<span class="comment">//i指向小于pivot的最后一个元素 </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = low;j&lt;high;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[j] &lt; pivot)&#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="built_in">swap</span>(arr[i],arr[j]);<span class="comment">//交换小于pivot的元素 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">swap</span>(arr[i<span class="number">+1</span>],arr[high]);</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> low,<span class="type">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high)&#123;</span><br><span class="line">        <span class="type">int</span> pi = <span class="built_in">Partition</span>(arr,low,high);</span><br><span class="line">        <span class="built_in">QuickSort</span>(arr,low,pi<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">QuickSort</span>(arr,pi<span class="number">+1</span>,high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-归并排序"><a href="#4-归并排序" class="headerlink" title="4.归并排序"></a>4.归并排序</h4><p>基本思想：<strong>拆分-合并</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> left,<span class="type">int</span> mid,<span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n1 = mid -left + <span class="number">1</span>,n2 = right - mid;</span><br><span class="line">    <span class="type">int</span> L[n1],R[n2];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n1;i++) L[i] = arr[left + i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; n2;j++) R[j] = arr[mid + <span class="number">1</span> + j];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,k = left;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n1 &amp;&amp; j &lt; n2)&#123;</span><br><span class="line">        arr[k++] = (L[i] &lt;= R[j]) ? L[i++] : R[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n1) arr[k++] = L[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt; n2) arr[k++] = R[j++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> left,<span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">MergeSort</span>(arr,left,mid);</span><br><span class="line">        <span class="built_in">MergeSort</span>(arr,mid<span class="number">+1</span>,right);</span><br><span class="line">        <span class="built_in">merge</span>(arr,left,mid,right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-堆排序"><a href="#5-堆排序" class="headerlink" title="5.堆排序"></a>5.堆排序</h4><p>思想：堆排序基于堆数据结构（最大堆或最小堆）</p>
<ol>
<li>构建大根堆（父节点 &gt;&#x3D; 子节点）。</li>
<li>交换堆顶元素与最后一个元素，并缩小堆的大小。</li>
<li>调整堆，保证堆结构完整。</li>
<li>重复步骤 2 和 3，直到排序完成。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapify</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> largest = i;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> right = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left &lt; n &amp;&amp; arr[left] &gt; arr[largest]) largest = left;</span><br><span class="line">    <span class="keyword">if</span> (right &lt; n &amp;&amp; arr[right] &gt; arr[largest]) largest = right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr[i], arr[largest]);</span><br><span class="line">        <span class="built_in">heapify</span>(arr, n, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) <span class="built_in">heapify</span>(arr, n, i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[i]);</span><br><span class="line">        <span class="built_in">heapify</span>(arr, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四、递推和递归"><a href="#四、递推和递归" class="headerlink" title="四、递推和递归"></a>四、递推和递归</h3><p><strong>递归结束条件和递归式</strong></p>
<ol>
<li><p>经典代码：斐波拉契数列、n的阶乘</p>
</li>
<li><p>如何探索递归顺序：转换为递归搜索树</p>
</li>
<li><p>恢复现场</p>
<h4 id="递归实现深度优先搜索"><a href="#递归实现深度优先搜索" class="headerlink" title="递归实现深度优先搜索"></a>递归实现深度优先搜索</h4></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 15</span></span><br><span class="line"><span class="type">int</span> arr[N]=&#123;&#125;;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="comment">//dfs表示每一个结点的状态 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i<span class="number">+1</span>);</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);    </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[u] = <span class="number">2</span>;<span class="comment">//2表示没选</span></span><br><span class="line">    <span class="built_in">dfs</span>(u<span class="number">+1</span>);</span><br><span class="line">    arr[u]= <span class="number">0</span>;<span class="comment">// 表示未考虑</span></span><br><span class="line"></span><br><span class="line">    arr[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(u<span class="number">+1</span>);</span><br><span class="line">    arr[u] = <span class="number">0</span>;<span class="comment">//恢复现场 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="递归实现排列"><a href="#递归实现排列" class="headerlink" title="递归实现排列"></a>递归实现排列</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="五、二分和前缀和"><a href="#五、二分和前缀和" class="headerlink" title="五、二分和前缀和"></a>五、二分和前缀和</h3><h4 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h4><p>确定一个区间使得目标值一定在区间中，找到一个性质满足：性质具有二段性；答案是二段性的分界点</p>
<ol>
<li><p>第一类：ans是红色区间的右端点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while(L &lt; R)&#123;</span><br><span class="line"> M =  (L+R+1) / 2;</span><br><span class="line"> if M 红   L =  M</span><br><span class="line"> else R = M - 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>第二类：ans是绿色区间的左端点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while(L &lt; R)&#123;</span><br><span class="line"> m =  (L+R) / 2;</span><br><span class="line"> if M 绿 R = M；</span><br><span class="line"> else L = M + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用,用于找最小可行解</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;    <span class="comment">// check()判断mid是否满足性质</span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：用于找最大可行解</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h5><p><img src="https://i-blog.csdnimg.cn/direct/5d5c6025e22447ce9251f9c53cdb45c6.png" alt="在这里插入图片描述"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,k;<span class="comment">//数组长度和询问个数 </span></span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d &quot;</span>,&amp;q[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m ; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;k);</span><br><span class="line">        <span class="comment">//二分x的左端点</span></span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r )/ <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(q[mid] &gt;= k) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>; </span><br><span class="line">         &#125; </span><br><span class="line">         <span class="keyword">if</span>(q[r] == k)&#123;</span><br><span class="line">             cout &lt;&lt; r &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">             r = n - <span class="number">1</span>;</span><br><span class="line">             <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">                 <span class="type">int</span> mid = (l + r + <span class="number">1</span>) /<span class="number">2</span>;</span><br><span class="line">                 <span class="keyword">if</span>(q[mid] &lt;= k)  l = mid;</span><br><span class="line">                 <span class="keyword">else</span> r = mid <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; l &lt;&lt; endl;     </span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             cout &lt;&lt; <span class="string">&quot;-1 -1&quot;</span> &lt;&lt; endl;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求解数的三次方根 </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    <span class="type">double</span> l = <span class="number">-10000</span>,r = <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">while</span>(r-l &gt; <span class="number">1e-8</span>)&#123;</span><br><span class="line">        <span class="type">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(mid * mid *mid &gt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lf\n&quot;</span>,l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="六、数学"><a href="#六、数学" class="headerlink" title="六、数学"></a>六、数学</h3><p>“化零为整”或“化整为零”</p>
<h4 id="1-最大公约数（欧几里得算法）"><a href="#1-最大公约数（欧几里得算法）" class="headerlink" title="1.最大公约数（欧几里得算法）"></a>1.最大公约数（欧几里得算法）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b,a%b) : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-最小公倍数"><a href="#2-最小公倍数" class="headerlink" title="2.最小公倍数"></a>2.最小公倍数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">lcm</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a / <span class="built_in">gcd</span>(a,b) * b ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-判断素数"><a href="#3-判断素数" class="headerlink" title="3.判断素数"></a>3.判断素数</h4><h4 id="4-进制转换"><a href="#4-进制转换" class="headerlink" title="4.进制转换"></a>4.进制转换</h4><h3 id="七、动态规划DP"><a href="#七、动态规划DP" class="headerlink" title="七、动态规划DP"></a>七、动态规划DP</h3><h4 id="1-01背包问题（每个物品仅选择一次）"><a href="#1-01背包问题（每个物品仅选择一次）" class="headerlink" title="1.01背包问题（每个物品仅选择一次）"></a>1.01背包问题（每个物品仅选择一次）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;<span class="comment">//</span></span><br><span class="line"><span class="type">int</span> v[N],w[N];<span class="comment">//体积和价值数组 </span></span><br><span class="line"><span class="type">int</span> f[N][N];<span class="comment">// f[i][j] 表示前 i 件物品，在容量为 j 的情况下的最大价值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;=n ; i++)  cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span> ; j &lt;=m ; j++)&#123;</span><br><span class="line">            f[i][j] = f[i<span class="number">-1</span>][j];<span class="comment">// 不选第 i 件物品，价值不变</span></span><br><span class="line">            <span class="keyword">if</span>(j &gt;= v[i]) f[i][j] = <span class="built_in">max</span>(f[i][j],f[i<span class="number">-1</span>][j-v[i]] + w[i]); <span class="comment">// 选第 i 件物品，则容量变为 j - v[i]，价值加上 w[i]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一维优化写法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;=n ; i++)  cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="comment">//从大到小遍历是因为要用到循环之前没更新过的值 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = m ; j &gt;= v[i] ; j--)&#123;</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j],f[j-v[i]] + w[i]); <span class="comment">// 选第 i 件物品，则容量变为 j - v[i]，价值加上 w[i]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-完全背包（每个物品可以选多次）"><a href="#2-完全背包（每个物品可以选多次）" class="headerlink" title="2.完全背包（每个物品可以选多次）"></a>2.完全背包（每个物品可以选多次）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="type">int</span> f[N]; <span class="comment">// 一维数组，f[j] 表示容量为 j 时的最大价值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">// 完全背包：从小到大遍历 j</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = v[i]; j &lt;= m; j++) &#123;</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-组合背包（一些无限次一些有限次）"><a href="#3-组合背包（一些无限次一些有限次）" class="headerlink" title="3.组合背包（一些无限次一些有限次）"></a>3.组合背包（一些无限次一些有限次）</h4><h3 id="八、贪心"><a href="#八、贪心" class="headerlink" title="八、贪心"></a>八、贪心</h3><h4 id="1-区间选点-活动安排问题"><a href="#1-区间选点-活动安排问题" class="headerlink" title="1.区间选点(活动安排问题)"></a>1.区间选点(活动安排问题)</h4><p><img src="https://i-blog.csdnimg.cn/direct/24696acd1595470d969e4316e73d4a82.png" alt="在这里插入图片描述"><br>思路：<br>1.将每个区间按右端点从小到大排序<br>2.从前往后依次枚举每个区间，如果当前区间中已经包含点，则直接pass，否则选择当前区间的右端点</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Range</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Range &amp;w)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> r &lt; w.r;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;range[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">        range[i] = &#123;l,r&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(range,range + n);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>,ed = <span class="number">-2e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ;i &lt; n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(range[i].l &gt; ed)&#123;</span><br><span class="line">            res ++ ;</span><br><span class="line">            ed = range[i].r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-区间分组"><a href="#2-区间分组" class="headerlink" title="2.区间分组"></a>2.区间分组</h4><p><img src="https://i-blog.csdnimg.cn/direct/205817f77056425bb09c916eb0511d8c.png" alt="在这里插入图片描述"></p>
<p>思路：<br>1.将所有区间按<strong>左端点</strong>从小到大排序<br>2.从前往后处理每个区间<br>        判断能否将其放到某个现有的组中(左端点小于已有区间中最大的右端点<strong>L[i] &gt; Max_r</strong>)<br>        若不存在这样的组，则开新组，然后再将其放进去；若存在这样的组，将其放进去，并更新当前组的Max_r</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Range</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Range &amp;w)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> l &lt; w.l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;range[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n ;i++)&#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">        range[i] = &#123;l,r&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(range,range + n);</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;<span class="type">int</span> , vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt; &gt; heap;<span class="comment">//定义小根堆 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">auto</span> r = range[i];</span><br><span class="line">        <span class="keyword">if</span>(heap.<span class="built_in">empty</span>() || heap.<span class="built_in">top</span>() &gt;= r.l) heap.<span class="built_in">push</span>(r.r);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">            heap.<span class="built_in">pop</span>();</span><br><span class="line">            heap.<span class="built_in">push</span>(r.r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,heap.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-区间覆盖"><a href="#3-区间覆盖" class="headerlink" title="3.区间覆盖"></a>3.区间覆盖</h4><p><img src="https://i-blog.csdnimg.cn/direct/a3ea596e097b48dbb99804c2cd3a86d7.png" alt="在这里插入图片描述"><br>思路：<br>1.将所有区间按<strong>左端点</strong>从小到大排序<br>2.从前往后处理每个区间，在所有能覆盖start的区间中，选择右端点最大的区间，然后将start更新成右端点的最大值（尽可能往右边延伸）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> n,start,ed;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Range</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Range &amp;w) <span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> l &lt; w.l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;range[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;start,&amp;ed);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n ; i++)&#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">        range[i] = &#123;l,r&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(range,range + n);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> success = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span> ; i &lt; n;i ++)&#123;</span><br><span class="line">        <span class="type">int</span> j = i,r = <span class="number">-2e9</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; n &amp;&amp; range[j].l &lt;= start)&#123;</span><br><span class="line">            r = <span class="built_in">max</span>(r,range[j].r);</span><br><span class="line">            j ++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(r &lt; start)&#123;</span><br><span class="line">            res = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res ++;</span><br><span class="line">        <span class="keyword">if</span>(r &gt;= ed)&#123;</span><br><span class="line">            success = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        start = r;</span><br><span class="line">        i = j - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!success) res = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-合并果子-哈夫曼树"><a href="#4-合并果子-哈夫曼树" class="headerlink" title="4.合并果子(哈夫曼树)"></a>4.合并果子(哈夫曼树)</h4><p><img src="https://i-blog.csdnimg.cn/direct/f5576c8e29b94741933e37a617cbc788.png" alt="在这里插入图片描述"><br>思路：将数存储在小根堆中，每次取堆顶相加，再push</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt; &gt; heap;</span><br><span class="line">    <span class="keyword">while</span>(n --)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        heap.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(heap.<span class="built_in">size</span>() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> a = heap.<span class="built_in">top</span>();heap.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> b = heap.<span class="built_in">top</span>();heap.<span class="built_in">pop</span>();</span><br><span class="line">        res += a + b;</span><br><span class="line">        heap.<span class="built_in">push</span>(a+b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="九、图论"><a href="#九、图论" class="headerlink" title="九、图论"></a>九、图论</h3><p>将题目转化为图的问题<br>例如1224交换瓶子可以转化为图论</p>
<h4 id="1-朴素Dijstra算法（对于边权非负的图，求单源最短路径）"><a href="#1-朴素Dijstra算法（对于边权非负的图，求单源最短路径）" class="headerlink" title="1.朴素Dijstra算法（对于边权非负的图，求单源最短路径）"></a>1.朴素Dijstra算法（对于边权非负的图，求单源最短路径）</h4><p>选择最近-标记走过-更新邻居</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 朴素 Dijkstra 算法</span></span><br><span class="line"><span class="comment">//1. 初始化 dist 数组，起点 dist[1] = 0</span></span><br><span class="line"><span class="comment">//2. 重复 n 次：</span></span><br><span class="line"><span class="comment">//    2.1 找距离最近的未处理点 t</span></span><br><span class="line"><span class="comment">//    2.2 标记 t 为已处理</span></span><br><span class="line"><span class="comment">//    2.3 用 t 更新邻居的最短距离</span></span><br><span class="line"><span class="comment">//3. 返回终点的距离（或判断是否可达）</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>; <span class="comment">// 表示一个“无限大”的值</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2022</span>;           <span class="comment">// 图中顶点个数（假设下标从1到N-1）</span></span><br><span class="line"><span class="type">int</span> graph[N][N]; <span class="comment">// 图的邻接矩阵表示，graph[i][j] 表示点i到点j的边权（0表示没有边）</span></span><br><span class="line"><span class="type">int</span> dist[N];     <span class="comment">// dist[i] 表示起点到点i的最短距离</span></span><br><span class="line"><span class="type">bool</span> st[N];      <span class="comment">// st[i] 表示点i是否已确定最短距离（是否已访问过）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist); <span class="comment">// 初始化所有距离为无穷大</span></span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// 起点是 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 找出当前未确定最短路的、距离最小的节点 t</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; N; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[j] &lt; dist[t])) &#123;</span><br><span class="line">                t = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">true</span>; <span class="comment">// 标记 t 为已确定</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新所有与 t 相邻的点 j 的最短距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; N; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (graph[t][j]) &#123; <span class="comment">// 如果 t 和 j 有边</span></span><br><span class="line">                dist[j] = <span class="built_in">min</span>(dist[j], dist[t] + graph[t][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dist[x] == INF) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 不可达</span></span><br><span class="line">    <span class="keyword">return</span> dist[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-BFS最短路模板（无权图）"><a href="#2-BFS最短路模板（无权图）" class="headerlink" title="2.BFS最短路模板（无权图）"></a>2.BFS最短路模板（无权图）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], index;</span><br><span class="line"><span class="type">int</span> dist[N];     <span class="comment">// 记录起点到每个点的最短距离</span></span><br><span class="line"><span class="type">bool</span> st[N];      <span class="comment">// 标记数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    e[index] = b;</span><br><span class="line">    ne[index] = h[a];</span><br><span class="line">    h[a] = index++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求从 start 到所有点的最短距离</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">-1</span>, <span class="keyword">sizeof</span> dist); <span class="comment">// -1 表示不可达</span></span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);  <span class="comment">// 初始化标记数组</span></span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    dist[start] = <span class="number">0</span>;</span><br><span class="line">    st[start] = <span class="literal">true</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(start);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i]) &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (!st[j]) &#123;</span><br><span class="line">                dist[j] = dist[t] + <span class="number">1</span>; <span class="comment">// 到 j 的最短距离 = 到 t 的距离 + 1</span></span><br><span class="line">                st[j] = <span class="literal">true</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h); <span class="comment">// 初始化邻接表</span></span><br><span class="line">    index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例建图（无向图）</span></span><br><span class="line">    <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="built_in">add</span>(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">3</span>); <span class="built_in">add</span>(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">add</span>(<span class="number">2</span>, <span class="number">4</span>); <span class="built_in">add</span>(<span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">add</span>(<span class="number">3</span>, <span class="number">5</span>); <span class="built_in">add</span>(<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> start = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">bfs</span>(start);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出从 start 到每个点的最短距离</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;dist[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; dist[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="一、队列（先进先出）"><a href="#一、队列（先进先出）" class="headerlink" title="一、队列（先进先出）"></a>一、队列（先进先出）</h3><p>对应<code>BFS</code><br><img src="https://i-blog.csdnimg.cn/direct/5c3ee2bb00d9424e8f8a7a9cb96690d8.png" alt="在这里插入图片描述"></p>
<h4 id="1-STL中的queue（双向队列）"><a href="#1-STL中的queue（双向队列）" class="headerlink" title="1.STL中的queue（双向队列）"></a>1.STL中的queue（双向队列）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-数组实现（循环数组）"><a href="#2-数组实现（循环数组）" class="headerlink" title="2.数组实现（循环数组）"></a>2.数组实现（循环数组）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写下关键的几句，方便记忆</span></span><br><span class="line"><span class="type">int</span> front, rear, size;</span><br><span class="line">rear = (rear + <span class="number">1</span>) % MAX_SIZE;</span><br></pre></td></tr></table></figure>

<h4 id="3-链表实现"><a href="#3-链表实现" class="headerlink" title="3.链表实现"></a>3.链表实现</h4><h4 id="4-优先队列（基于堆实现）"><a href="#4-优先队列（基于堆实现）" class="headerlink" title="4.优先队列（基于堆实现）"></a>4.优先队列（基于堆实现）</h4><p><strong>解释</strong>：优先队列是一种 特殊的队列，它内部的元素按照一定的优先级自动排序，取出元素时总是取优先级最高的那个元素。<br><strong>适用</strong>：优先队列适合解决 “<strong>动态、实时选择最大（或最小）</strong>” 的问题</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>&gt; pq; <span class="comment">// 最大值优先</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; pq; <span class="comment">// 最小值优先</span></span><br><span class="line"></span><br><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; pq; <span class="comment">// 按 pair 的 first 从大到小</span></span><br><span class="line"></span><br><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, greater&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; pq; <span class="comment">// first 从小到大</span></span><br></pre></td></tr></table></figure>

<h4 id="4-BFS"><a href="#4-BFS" class="headerlink" title="4.BFS"></a>4.BFS</h4><p>涉及：</p>
<ul>
<li><p>判重数组（入队时判重）</p>
</li>
<li><p>队列结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">queue &lt;- 初始状态</span><br><span class="line">while（queue非空）&#123;</span><br><span class="line">          取出队头元素</span><br><span class="line">          for（拓展的所有元素）&#123;</span><br><span class="line">                      ver &lt;- 新节点</span><br><span class="line">                      if（！st[ver]）&#123;</span><br><span class="line">                          ver-&gt;队尾</span><br><span class="line">                      &#125;</span><br><span class="line">           &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迷宫问题</p>
</li>
</ul>
<h3 id="二、栈（先进后出）"><a href="#二、栈（先进后出）" class="headerlink" title="二、栈（先进后出）"></a>二、栈（先进后出）</h3><p>对应<code>递归</code>，<code>DFS</code></p>
<h4 id="1-栈的基本操作"><a href="#1-栈的基本操作" class="headerlink" title="1.栈的基本操作"></a>1.栈的基本操作</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span>  <span class="comment">//引入头文件</span></span></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; stk;   <span class="comment">//定义</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i-blog.csdnimg.cn/direct/17d2d3fc63124bc89371fb469fb74f16.png" alt="在这里插入图片描述"></p>
<h4 id="2-实现DFS"><a href="#2-实现DFS" class="headerlink" title="2.实现DFS"></a>2.实现DFS</h4><p>作用：确认是否连通</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从点u开始进行DFS遍历 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    st[u] = <span class="literal">true</span>;<span class="comment">//表示点u被遍历过,判重数组 </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u];i != <span class="number">-1</span>; i = ne[i])&#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];<span class="comment">//j 是 u 的邻接点 </span></span><br><span class="line">        <span class="keyword">if</span>(!st[j]) <span class="built_in">dfs</span>(j);<span class="comment">//如果点j没有被访问过，就递归调用dfs(j) </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="三、图"><a href="#三、图" class="headerlink" title="三、图"></a>三、图</h3><h4 id="1-邻接矩阵（适用于稠密图）"><a href="#1-邻接矩阵（适用于稠密图）" class="headerlink" title="1.邻接矩阵（适用于稠密图）"></a>1.邻接矩阵（适用于稠密图）</h4><p>无向图的创建和遍历</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VertexType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> EdgeType;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXVEX 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFINITY 65535</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    VertexType vexs[MAXVEX];<span class="comment">//顶点表</span></span><br><span class="line">    EdgeType arc[MAXVEX][MAXVEX];<span class="comment">//邻接矩阵 </span></span><br><span class="line">    <span class="type">int</span> numVertexes,numEdges;<span class="comment">//图中顶点和边的数量 </span></span><br><span class="line"> &#125; MGraph;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">CreateMGraph</span><span class="params">(MGraph *G)</span></span>&#123;</span><br><span class="line">     <span class="type">int</span> i,j,k,w;</span><br><span class="line">     <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;G-&gt;numVertexes,&amp;G-&gt;numEdges);</span><br><span class="line">     <span class="comment">//获得邻接表 </span></span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G-&gt;numVertexes;i++)&#123;</span><br><span class="line">         <span class="built_in">scanf</span>(<span class="string">&quot; %c&quot;</span>,&amp;G-&gt;vexs[i]);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//邻接矩阵初始化 </span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G-&gt;numVertexes;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G-&gt;numVertexes;j++)&#123;</span><br><span class="line">            G-&gt;arc[i][j]=INFINITY;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;G-&gt;numEdges;k++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入边（vi，vj）上的下标i，下标j和权w：\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;i,&amp;j,&amp;w);</span><br><span class="line">        G-&gt;arc[i][j] = w;</span><br><span class="line">        G-&gt;arc[j][i] = G-&gt;arc[i][j];</span><br><span class="line">    &#125; </span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    MGraph *graph = <span class="keyword">new</span> <span class="built_in">MGraph</span>();</span><br><span class="line">    <span class="built_in">memset</span>(graph,<span class="number">0</span>,<span class="built_in">sizeof</span>(MGraph));</span><br><span class="line">    <span class="built_in">CreateMGraph</span>(graph);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;graph-&gt;numVertexes;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;graph-&gt;numVertexes;j++)&#123;</span><br><span class="line">            cout&lt;&lt;graph-&gt;arc[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> graph; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意点：</p>
<ul>
<li><p>结构体的创建</p>
</li>
<li><p>创建实例时需要先分配内存，用malloc函数或者new关键字</p>
</li>
<li><p>memset的作用是清楚结构体成员，sizeof函数内是数据类型，这里是结构体类型；*graph作为指针</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MGraph *graph = <span class="keyword">new</span> <span class="built_in">MGraph</span>();</span><br><span class="line"><span class="comment">//MGraph *graph = (MGraph*)malloc(sizeof(MGraph));</span></span><br><span class="line"><span class="built_in">memset</span>(graph, <span class="number">0</span>, <span class="built_in">sizeof</span>(MGraph));</span><br></pre></td></tr></table></figure></li>
<li><p><strong>读取字符时用scanf可能会读取换行符，如果想跳过，需要在前面加空格</strong>；scanf也不能正确读取逗号分隔的输入，一般用空格分隔</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot; %c&quot;</span>, &amp;G-&gt;vexs[i]);  <span class="comment">// 读取字符</span></span><br></pre></td></tr></table></figure>

<h4 id="2-邻接表（适用于稀疏图）"><a href="#2-邻接表（适用于稀疏图）" class="headerlink" title="2.邻接表（适用于稀疏图）"></a>2.邻接表（适用于稀疏图）</h4><p>头插法</p>
<h5 id="2-1-用数组模拟链表结构-节省空间"><a href="#2-1-用数组模拟链表结构-节省空间" class="headerlink" title="2.1 用数组模拟链表结构-节省空间"></a>2.1 用数组模拟链表结构-节省空间</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.h[N]表示每个头的链表头指针，h[a]是点a的邻接链表的起始下标</span></span><br><span class="line"><span class="comment">//2.e[N]存放所有的边的终点，例如e[i] = b表示第i条边的终点是b</span></span><br><span class="line"><span class="comment">//3.ne[N]相当于next数组，表示当前这条边的下一条边在数组中的位置，也就是next指针</span></span><br><span class="line"><span class="comment">//4.index是数组e和ne的下标 </span></span><br><span class="line"><span class="type">int</span> h[N],e[N],ne[N],index;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    e[index] = b;          <span class="comment">// 把 b 存为边的终点</span></span><br><span class="line">    ne[index] = h[a];      <span class="comment">// 当前这条边的“下一条”指向之前的头（即老的 h[a]）</span></span><br><span class="line">    h[a] = index++;        <span class="comment">// 更新 h[a]，新边插到最前面；index 自增</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">index = <span class="number">0</span> ;</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//从点u开始进行DFS遍历 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    st[u] = <span class="literal">true</span>;<span class="comment">//表示点u被遍历过,判重数组 </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u];i != <span class="number">-1</span>; i = ne[i])&#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];<span class="comment">//j 是 u 的邻接点 </span></span><br><span class="line">        <span class="keyword">if</span>(!st[j]) <span class="built_in">dfs</span>(j);<span class="comment">//如果点j没有被访问过，就递归调用dfs(j) </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    st[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(u);<span class="comment">//标记遍历后入队 </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();<span class="comment">//队头</span></span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t];i != <span class="number">-1</span>;i = ne[i])&#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(!st[j])&#123;</span><br><span class="line">                st[j] = <span class="literal">true</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="训练题"><a href="#训练题" class="headerlink" title="训练题"></a>训练题</h2><h3 id="1-670动物"><a href="#1-670动物" class="headerlink" title="1. 670动物"></a>1. 670动物</h3><p><img src="https://i-blog.csdnimg.cn/direct/2f8739ae99364aed804164b33e4c49f8.png" alt="在这里插入图片描述"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">      string a[<span class="number">3</span>];</span><br><span class="line">    string ss;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++) cin &gt;&gt; a[i],ss+=a[i][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ss==<span class="string">&quot;vac&quot;</span>) cout&lt;&lt;<span class="string">&quot;aguia&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(ss==<span class="string">&quot;vao&quot;</span>) cout&lt;&lt;<span class="string">&quot;pomba&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(ss==<span class="string">&quot;vmo&quot;</span>) cout&lt;&lt;<span class="string">&quot;homem&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(ss==<span class="string">&quot;vmh&quot;</span>) cout&lt;&lt;<span class="string">&quot;vaca&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(ss==<span class="string">&quot;iih&quot;</span>) <span class="comment">// 情况特殊</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">2</span>] == <span class="string">&quot;hematofago&quot;</span>) cout&lt;&lt;<span class="string">&quot;pulga&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;lagarta&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ss==<span class="string">&quot;iah&quot;</span>) cout&lt;&lt;<span class="string">&quot;sanguessuga&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(ss==<span class="string">&quot;iao&quot;</span>) cout&lt;&lt;<span class="string">&quot;minhoca&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码是一位大佬发布的题解，我觉得思路很巧妙就记录下来，如果单个单词判断会显得很复杂，但是可以通过判断首字母来是否属于某一类单词，将对应的首字母添加到字符数组再判断就可以了</p>
<h3 id="2-数组的区域"><a href="#2-数组的区域" class="headerlink" title="2. 数组的区域"></a>2. 数组的区域</h3><p><img src="https://i-blog.csdnimg.cn/direct/6e63b20d49a54247bcd50b318baeb2c9.png" alt="在这里插入图片描述"><br>将网格看成坐标系，对角线看成线性函数，求两个函数的大小关系</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> S;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> M[<span class="number">12</span>][<span class="number">12</span>]=&#123;&#125;,sum = <span class="number">0.00</span>;</span><br><span class="line">    cin &gt;&gt; S;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">12</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">12</span>;j++)&#123;</span><br><span class="line">            cin &gt;&gt; M[i][j];</span><br><span class="line">            <span class="keyword">if</span>(i &gt; j &amp;&amp; j &lt; <span class="number">11</span> - i) &#123;</span><br><span class="line">                sum += M[i][j];</span><br><span class="line">                count ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.1f&quot;</span>,S == <span class="string">&#x27;S&#x27;</span> ? sum :sum/count);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-平方矩阵I"><a href="#3-平方矩阵I" class="headerlink" title="3.平方矩阵I"></a>3.平方矩阵I</h3><p><img src="https://i-blog.csdnimg.cn/direct/d9fbb32f908f452894d446a0e95f971c.png" alt="在这里插入图片描述"></p>
<h6 id="解法一：填充矩阵"><a href="#解法一：填充矩阵" class="headerlink" title="解法一：填充矩阵"></a>解法一：填充矩阵</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> N;</span><br><span class="line">    <span class="type">int</span> martrix[<span class="number">100</span>][<span class="number">100</span>]=&#123;&#125;;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; N ,N)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> layer = <span class="number">0</span> ;layer &lt; (N<span class="number">+1</span>)/<span class="number">2</span>;layer ++)&#123;</span><br><span class="line">            <span class="type">int</span> val = layer + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = layer ; i &lt; N -layer;i++)&#123;</span><br><span class="line">                martrix[layer][i] = val;</span><br><span class="line">                martrix[N - layer - <span class="number">1</span>][i] = val;</span><br><span class="line">                martrix[i][layer] = val;</span><br><span class="line">                martrix[i][N-layer - <span class="number">1</span>] = val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">                cout &lt;&lt; martrix[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">           &#125;</span><br><span class="line">           cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解法二：对角线"><a href="#解法二：对角线" class="headerlink" title="解法二：对角线"></a>解法二：对角线</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> N;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">100</span>][<span class="number">100</span>]=&#123;&#125;;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; N ,N)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; N - i; j ++ )</span><br><span class="line">            &#123;</span><br><span class="line">                a[j][i] = a[i][j] = i + <span class="number">1</span>;</span><br><span class="line">                a[j][N - i - <span class="number">1</span>] = a[N - i - <span class="number">1</span>][j] = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">                cout &lt;&lt; a[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">           &#125;</span><br><span class="line">           cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-最大公约数"><a href="#4-最大公约数" class="headerlink" title="4.最大公约数"></a>4.最大公约数</h3><h4 id="解法一：逐个判断"><a href="#解法一：逐个判断" class="headerlink" title="解法一：逐个判断"></a>解法一：逐个判断</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> max = a;</span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line">    <span class="keyword">if</span>(a &lt; b)&#123;</span><br><span class="line">        max = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=max;i &gt; <span class="number">0</span> ; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a % i == <span class="number">0</span> &amp;&amp; b% i ==<span class="number">0</span>)&#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="built_in">gcd</span>(a,b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解法二：欧几里得算法（辗转相除法）"><a href="#解法二：欧几里得算法（辗转相除法）" class="headerlink" title="解法二：欧几里得算法（辗转相除法）"></a>解法二：欧几里得算法（辗转相除法）</h4><p>基本思想：两个正整数的最大公约数等于<strong>其中较小数和两数相除余数的最大公约数</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a%b==<span class="number">0</span>) <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">gcd</span>(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">gcd</span>(a,b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-小球反弹问题"><a href="#5-小球反弹问题" class="headerlink" title="5.小球反弹问题"></a>5.小球反弹问题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 计算最大公约数（GCD）</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">gcd</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">long</span> <span class="type">long</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算最小公倍数（LCM）</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">lcm</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">long</span> <span class="type">long</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a / <span class="built_in">gcd</span>(a, b) * b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout.<span class="built_in">precision</span>(<span class="number">2</span>);</span><br><span class="line">    cout&lt;&lt;fixed;</span><br><span class="line">    <span class="type">int</span> dx=<span class="number">15</span>,dy=<span class="number">17</span>; </span><br><span class="line">    <span class="type">int</span> width=<span class="number">343720</span>*<span class="number">2</span>,height=<span class="number">233333</span>*<span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> dt=<span class="built_in">lcm</span>(dx,width)/dx;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=dt;;t+=dt)&#123;</span><br><span class="line">        <span class="keyword">if</span>(t*dy %height ==<span class="number">0</span>)&#123;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">hypot</span>(t*dx,t*dy);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-好数"><a href="#6-好数" class="headerlink" title="6.好数"></a>6.好数</h3><h4 id="解法一：枚举法"><a href="#解法一：枚举法" class="headerlink" title="解法一：枚举法"></a>解法一：枚举法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断一个数是否是“好数”</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isGoodNumber</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pos = <span class="number">1</span>; <span class="comment">// 记录当前是第几位（从右向左数）</span></span><br><span class="line">    <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> digit = num % <span class="number">10</span>; <span class="comment">// 取当前最低位</span></span><br><span class="line">        <span class="keyword">if</span> (pos % <span class="number">2</span> == <span class="number">1</span>) &#123; <span class="comment">// 奇数位</span></span><br><span class="line">            <span class="keyword">if</span> (digit % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 奇数位上必须是奇数</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 偶数位</span></span><br><span class="line">            <span class="keyword">if</span> (digit % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 偶数位上必须是偶数</span></span><br><span class="line">        &#125;</span><br><span class="line">        num /= <span class="number">10</span>; <span class="comment">// 去掉最低位</span></span><br><span class="line">        pos++; <span class="comment">// 位置 +1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统计 1 到 N 之间的好数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">countGoodNumbers</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isGoodNumber</span>(i)) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> N;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">countGoodNumbers</span>(N) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解法二：数字动态规划"><a href="#解法二：数字动态规划" class="headerlink" title="解法二：数字动态规划"></a>解法二：数字动态规划</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string numStr;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">20</span>][<span class="number">2</span>][<span class="number">2</span>]; <span class="comment">// dp[pos][isLimit][isNum] 记录状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归函数，返回构造好数的数量</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos, <span class="type">bool</span> isLimit, <span class="type">bool</span> isNum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pos == numStr.<span class="built_in">size</span>()) <span class="keyword">return</span> isNum; <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (!isLimit &amp;&amp; dp[pos][isLimit][isNum] != <span class="number">-1</span>) <span class="keyword">return</span> dp[pos][isLimit][isNum];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> up = isLimit ? numStr[pos] - <span class="string">&#x27;0&#x27;</span> : <span class="number">9</span>; <span class="comment">// 当前位置能填的最大值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> d = <span class="number">0</span>; d &lt;= up; d++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pos % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; d % <span class="number">2</span> == <span class="number">1</span>) || (pos % <span class="number">2</span> == <span class="number">1</span> &amp;&amp; d % <span class="number">2</span> == <span class="number">0</span>)) &#123; <span class="comment">// 确保奇偶位符合规则</span></span><br><span class="line">            res += <span class="built_in">dfs</span>(pos + <span class="number">1</span>, isLimit &amp;&amp; (d == up), isNum || d &gt; <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isLimit) dp[pos][isLimit][isNum] = res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算 1 到 N 之间的好数个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">countGoodNumbers</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="built_in">sizeof</span>(dp)); <span class="comment">// 初始化 dp 数组</span></span><br><span class="line">    numStr = <span class="built_in">to_string</span>(N);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> N;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">countGoodNumbers</span>(N) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-R格式"><a href="#7-R格式" class="headerlink" title="7.R格式"></a>7.R格式</h3><h4 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">convertToRFormat</span><span class="params">(<span class="type">double</span> d, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">round</span>(d * <span class="built_in">pow</span>(<span class="number">2</span>, n));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> d=<span class="number">0.00</span>;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt;d;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">convertToRFormat</span>(d,n);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>round()函数</code>：浮点数四舍五入<br><code>pow()函数</code>：计算幂函数</p>
<h3 id="8-宝石组合"><a href="#8-宝石组合" class="headerlink" title="8.宝石组合"></a>8.宝石组合</h3><p><img src="https://i-blog.csdnimg.cn/direct/8d319e822cea4cbfa54d786ca1f2883b.png" alt="在这里插入图片描述"><br>解题思路：<br>1.任选三种宝石进行排列组合（遍历）<br>2.选出三种宝石后计算精美程度（计算精美程度作为一个函数调用）<br>3.按字典序最小方案选择</p>
<h4 id="解法一：暴力"><a href="#解法一：暴力" class="headerlink" title="解法一：暴力"></a>解法一：暴力</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">gcd</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">long</span> <span class="type">long</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b==<span class="number">0</span> ? a : <span class="built_in">gcd</span>(b,a%b) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">lcm</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a,<span class="type">long</span> <span class="type">long</span> b)</span></span>&#123;</span><br><span class="line"><span class="comment">//    return a*b / gcd(a,b);</span></span><br><span class="line"><span class="keyword">return</span> a*<span class="built_in">gcd</span>(a,b)/b;<span class="comment">//避免溢出 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">H</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="type">int</span> bestTriple[<span class="number">3</span>]=&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin &gt;&gt; H[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(H.<span class="built_in">begin</span>(),H.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> maxS = <span class="number">0</span>;</span><br><span class="line">     <span class="comment">// 遍历所有三元组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = j + <span class="number">1</span>; k &lt; n; k++) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> Ha = H[i], Hb = H[j], Hc = H[k];</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> L_ab = <span class="built_in">lcm</span>(Ha, Hb);</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> L_ac = <span class="built_in">lcm</span>(Ha, Hc);</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> L_bc = <span class="built_in">lcm</span>(Hb, Hc);</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> L_abc = <span class="built_in">lcm</span>(L_ab, Hc);</span><br><span class="line"></span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> S = (Ha * Hb * Hc * L_abc) / (L_ab * L_ac * L_bc);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (S &gt; maxS) &#123;</span><br><span class="line">                    maxS = S;</span><br><span class="line">                    bestTriple[<span class="number">0</span>] = H[i];</span><br><span class="line">                    bestTriple[<span class="number">1</span>] = H[j];</span><br><span class="line">                    bestTriple[<span class="number">2</span>] = H[k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     cout &lt;&lt; bestTriple[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; bestTriple[<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; bestTriple[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>sort()函数</code>：不想手写排序算法时，可以用这个，不过前提是数组需要是vector类型，也就是用到了STL容器</p>
<h3 id="9-数组接龙"><a href="#9-数组接龙" class="headerlink" title="9.数组接龙"></a>9.数组接龙</h3><p><img src="https://i-blog.csdnimg.cn/direct/44b6b6c960b548c98d1b45ea43485fff.png" alt="在这里插入图片描述"><br><img src="https://i-blog.csdnimg.cn/direct/77a6a82ad3d640f08b810d491351bdcd.png" alt="在这里插入图片描述"><br>初步思路：解决输入问题，有约束条件，应该涉及回溯和搜索<br>最终思路：</p>
<ol>
<li><strong>深度优先搜索（DFS）</strong><br>需要维护 visited 数组来记录哪些格子已经访问过。</li>
<li>使用 <strong>path</strong> 记录当前的行进方向序列。<br>遍历所有 8 个方向，按照编号 0-7 的顺序，保证字典序最小。</li>
<li>路径合法性检查</li>
</ol>
<ul>
<li>只能按 0,1,2,…,K-1 的顺序访问格子。</li>
<li>不能访问已经走过的格子。</li>
</ul>
<ol start="4">
<li><p>终止条件<br>终点 (N-1, N-1) 处所有格子均访问完毕，则输出路径。如果找不到满足条件的路径，返回 -1</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 100</span></span><br><span class="line"><span class="comment">//定义8个方向 </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dx[<span class="number">8</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dy[<span class="number">8</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> N=<span class="number">0</span>,K=<span class="number">0</span>;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; grid;</span><br><span class="line">vector&lt;vector&lt;<span class="type">bool</span>&gt; &gt; visited;</span><br><span class="line">string bestPath;</span><br><span class="line">string curPath;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>bool isValid(int x,int y,int expected) {<br>    &#x2F;&#x2F;expected判断下一个值是不是满足 0,1,2,…,K-1<br>    return (x &gt;&#x3D;0 &amp;&amp; x &lt; N &amp;&amp; y &gt;&#x3D; 0 &amp;&amp; y &lt; N &amp;&amp; !visited[x][y] &amp;&amp; grid [x][y] &#x3D;&#x3D; expected);<br>}</p>
<p>void DFS(int x,int y,int step){<br>    if(x &#x3D;&#x3D; N-1 &amp;&amp; y &#x3D;&#x3D; N-1){ &#x2F;&#x2F;到达终点<br>        if(bestPath.empty() || curPath &lt; bestPath)<br>            bestPath &#x3D; curPath;<br>        return;<br>    }<br>    for(int d&#x3D;0;d &lt; 8 ;d++){<br>        int nx &#x3D; x +dx[d];<br>        int ny &#x3D; y +dy[d];<br>        int nextValue &#x3D; (step +1) &amp; K;</p>
<pre><code>if (isValid(nx, ny, nextValue)) &#123;
        vis[nx][ny] = true;
        curPath += (&#39;0&#39; + d);  // 记录路径方向

        dfs(nx, ny, step + 1);

        curPath.pop_back();  // 回溯
        vis[nx][ny] = false;
    &#125;     
&#125;
</code></pre>
<p>}</p>
<p>int main(){<br>    cin &gt;&gt; N &gt;&gt; K;<br>    grid.resize(N, vector<int>(N));<br>    vis.resize(N, vector<bool>(N, false));</p>
<pre><code>for (int i = 0; i &lt; N; i++)
    for (int j = 0; j &lt; N; j++)
        cin &gt;&gt; grid[i][j];

if (grid[0][0] != 0) &#123;  // 初始位置必须是 0，否则无解
    cout &lt;&lt; -1 &lt;&lt; endl;
    return 0;
&#125;

vis[0][0] = true;
dfs(0, 0, 0);

cout &lt;&lt; (bestPath.empty() ? &quot;-1&quot; : bestPath) &lt;&lt; endl;

return 0;
</code></pre>
<p>} </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">### 10.爬山</span><br><span class="line">![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/d2ba3b0f79f540c2afb37d6ce58edb73.png)</span><br><span class="line">初步思路：</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">double MagicalOne(int h)&#123;</span><br><span class="line">    return pow(h,1/2);</span><br><span class="line">&#125;</span><br><span class="line">double MagicalTwo(int h)&#123;</span><br><span class="line">    return h/2;</span><br><span class="line">&#125;</span><br><span class="line">double MinPower()&#123;</span><br><span class="line">    int n,P,Q,sum = 0;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; P &gt;&gt; Q;</span><br><span class="line">    vector&lt;int&gt; H(n);</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        cin &gt;&gt; H[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for(auto h:H)&#123;</span><br><span class="line">        h1 = MagicalOne(h);</span><br><span class="line">        h2 = MagicalTwo(h);</span><br><span class="line">        if(h1 &lt; h2 &amp;&amp; P &gt; 0) &#123;</span><br><span class="line">            sum += h1;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(h2 &lt; h1 &amp;&amp; Q &gt; 0)&#123;</span><br><span class="line">            sum += h2;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            sum += h;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    cout &lt;&lt; MinPower() &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><strong>错误点</strong>：</p>
<ol>
<li>魔法是有限次数，并且可能重复使用在同一座山上（直到次数耗尽或继续用无意义），需要全局最优分配，而不仅仅是某一座山上局部最优！</li>
<li>1&#x2F;2 是 整数除法，结果为 0</li>
<li>h1 和 h2 未定义</li>
<li>核心问题：需要贪心选择，把魔法分配给收益最大的山，而你代码是本地贪心（逐个山判断局部最优），无法保证全局最优！</li>
</ol>
<p><strong>正确思路</strong><br><img src="https://i-blog.csdnimg.cn/direct/303a1a8fe9174549b398869e639d1c63.png" alt="在这里插入图片描述"><br><strong>正确代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种魔法：向下取整开方</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MagicalOne</span><span class="params">(<span class="type">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)<span class="built_in">floor</span>(<span class="built_in">sqrt</span>(h));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种魔法：减半</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MagicalTwo</span><span class="params">(<span class="type">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义比较器，让优先队列变成最大堆</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&gt;&amp; a, <span class="type">const</span> tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(a) &lt; <span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(b); <span class="comment">// 按收益降序排列</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">MinPower</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, P, Q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; P &gt;&gt; Q;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">H</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; H[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&gt; &gt;, cmp&gt; pq;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化每个山头的两种魔法收益</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> h = H[i];</span><br><span class="line">        <span class="type">int</span> gain1 = h - <span class="built_in">MagicalOne</span>(h);</span><br><span class="line">        <span class="type">int</span> gain2 = h - <span class="built_in">MagicalTwo</span>(h);</span><br><span class="line">        <span class="keyword">if</span> (gain1 &gt; <span class="number">0</span>) pq.<span class="built_in">push</span>(<span class="built_in">make_tuple</span>(gain1, <span class="number">1</span>, i)); <span class="comment">// 使用 make_tuple</span></span><br><span class="line">        <span class="keyword">if</span> (gain2 &gt; <span class="number">0</span>) pq.<span class="built_in">push</span>(<span class="built_in">make_tuple</span>(gain2, <span class="number">2</span>, i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 贪心使用魔法</span></span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>() &amp;&amp; (P &gt; <span class="number">0</span> || Q &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">        tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&gt; t = pq.<span class="built_in">top</span>(); pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> gain = <span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(t);</span><br><span class="line">        <span class="type">int</span> type = <span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(t);</span><br><span class="line">        <span class="type">int</span> idx = <span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(t);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (gain &lt;= <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">1</span> &amp;&amp; P &gt; <span class="number">0</span>) &#123; <span class="comment">// 第一种魔法</span></span><br><span class="line">            H[idx] = <span class="built_in">MagicalOne</span>(H[idx]);</span><br><span class="line">            P--;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span> &amp;&amp; Q &gt; <span class="number">0</span>) &#123; <span class="comment">// 第二种魔法</span></span><br><span class="line">            H[idx] = <span class="built_in">MagicalTwo</span>(H[idx]);</span><br><span class="line">            Q--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// 次数不足，跳过</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新计算收益</span></span><br><span class="line">        <span class="type">int</span> new_gain1 = H[idx] - <span class="built_in">MagicalOne</span>(H[idx]);</span><br><span class="line">        <span class="type">int</span> new_gain2 = H[idx] - <span class="built_in">MagicalTwo</span>(H[idx]);</span><br><span class="line">        <span class="keyword">if</span> (new_gain1 &gt; <span class="number">0</span>) pq.<span class="built_in">push</span>(<span class="built_in">make_tuple</span>(new_gain1, <span class="number">1</span>, idx));</span><br><span class="line">        <span class="keyword">if</span> (new_gain2 &gt; <span class="number">0</span>) pq.<span class="built_in">push</span>(<span class="built_in">make_tuple</span>(new_gain2, <span class="number">2</span>, idx));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算最终总和</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) sum += H[i];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">MinPower</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-拔河-二分查找"><a href="#11-拔河-二分查找" class="headerlink" title="11.拔河(二分查找)"></a>11.拔河(二分查找)</h3><p><img src="https://i-blog.csdnimg.cn/direct/3d2c7f52237b45c98ddbe4d528cd5caa.png" alt="在这里插入图片描述"><br><strong>目标</strong>：从一个序列中选择两个不相交的连续子区间，使得它们的和的差值尽可能小，即 |sum1 - sum2| 最小。<br><strong>方法</strong>：由于题目保证编号连续，且两个区间不能重叠，所以我们可以：</p>
<ol>
<li>枚举第一个区间的左右端点 (l1, r1)，</li>
<li>枚举第二个区间的左右端点 (l2, r2)，其中 l2 &gt; r1。</li>
<li>分别计算两个区间的和，然后取他们的差的绝对值。<br><strong>优化</strong>：<br>预处理前缀和数组：<code>sum[i] 表示 a[1] 到 a[i] 的和（注意这里从1开始）。 </code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">105</span>;</span><br><span class="line"><span class="type">int</span> a[MAXN];</span><br><span class="line"><span class="type">int</span> sum[MAXN]; <span class="comment">// 前缀和</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        sum[i] = sum[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> min_diff = INT_MAX;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 枚举第一个区间 [l1, r1]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> l1 = <span class="number">1</span>; l1 &lt;= n; l1++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> r1 = l1; r1 &lt;= n; r1++) &#123;</span><br><span class="line">            <span class="type">int</span> sum1 = sum[r1] - sum[l1 - <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 枚举第二个区间 [l2, r2], l2 必须 &gt; r1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> l2 = r1 + <span class="number">1</span>; l2 &lt;= n; l2++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> r2 = l2; r2 &lt;= n; r2++) &#123;</span><br><span class="line">                    <span class="type">int</span> sum2 = sum[r2] - sum[l2 - <span class="number">1</span>];</span><br><span class="line">                    <span class="type">int</span> diff = <span class="built_in">abs</span>(sum1 - sum2);</span><br><span class="line">                    min_diff = <span class="built_in">min</span>(min_diff, diff);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; min_diff &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i-blog.csdnimg.cn/direct/5abd290e48f54ac9b24cd43dbf436847.png" alt="在这里插入图片描述"></p>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2025/07/01/CppLearn/">蓝桥杯准备-C++</a></p>
        <p><span>文章作者:</span><a href="/" title="回到主页"></a></p>
        <p><span>发布时间:</span>2025-07-01, 00:00:00</p>
        <p><span>最后更新:</span>2025-07-10, 13:11:40</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2025/07/01/CppLearn/" title="蓝桥杯准备-C++">http://example.com/2025/07/01/CppLearn/</a>
            <span class="copy-path" data-clipboard-text="原文: http://example.com/2025/07/01/CppLearn/　　作者: " title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2025/07/01/PythonLearn/">
                    Python基础
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2025/07/01/git-operations/">
                    Git操作
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">文章目录</strong>
        
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%EF%BC%9A%E4%BB%A5%E4%B8%8B%E6%98%AFACWing%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8C%E8%8B%A5%E6%9C%89%E4%BE%B5%E6%9D%83%E8%81%94%E7%B3%BB%E6%88%91%E5%88%A0%E9%99%A4%E6%96%87%E7%AB%A0"><span class="toc-number">1.</span> <span class="toc-text">注意：以下是ACWing课程学习笔记，若有侵权联系我删除文章</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="toc-number">1.1.</span> <span class="toc-text">基础语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%85%A5%E9%97%A8"><span class="toc-number">1.1.1.</span> <span class="toc-text">1. 入门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8F%98%E9%87%8F"><span class="toc-number">1.1.2.</span> <span class="toc-text">2. 变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B-5%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.3.</span> <span class="toc-text">3. 变量类型(5种基本数据类型)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%EF%BC%89%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.1.4.</span> <span class="toc-text">4.表达式（加减乘除）和运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-C-%E4%B8%AD%E7%9A%84%E5%88%A4%E6%96%AD%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.5.</span> <span class="toc-text">5.C++中的判断结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-C-%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84"><span class="toc-number">1.1.6.</span> <span class="toc-text">6.C++中的数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.1.7.</span> <span class="toc-text">7.字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.8.</span> <span class="toc-text">8.函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E7%B1%BB%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93%E3%80%81%E6%8C%87%E9%92%88%E3%80%81%E5%BC%95%E7%94%A8"><span class="toc-number">1.1.9.</span> <span class="toc-text">9.类、结构体、指针、引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-STL"><span class="toc-number">1.1.10.</span> <span class="toc-text">10.STL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E4%BD%8D%E8%BF%90%E7%AE%97%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%BA%93%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.11.</span> <span class="toc-text">11.位运算与常用库函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-auto%E5%86%99%E6%B3%95"><span class="toc-number">1.1.12.</span> <span class="toc-text">12.auto写法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">基础算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%9F%BA%E6%9C%AC"><span class="toc-number">1.2.1.</span> <span class="toc-text">一、基本</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%AB%98%E7%B2%BE%E5%BA%A6"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">1.高精度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.2.</span> <span class="toc-text">二、搜索算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-DFS-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95%EF%BC%88%E9%80%92%E5%BD%92%E6%88%96%E6%A0%88%E5%AE%9E%E7%8E%B0%EF%BC%89"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">1. DFS-深度优先算法（递归或栈实现）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-BFS-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95%EF%BC%88%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%EF%BC%89"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">2.BFS-广度优先算法（队列实现）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.3.</span> <span class="toc-text">三、排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">1.插入排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%EF%BC%88Shell-Sort%EF%BC%89-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%9A%84%E4%BC%98%E5%8C%96%E7%89%88"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">希尔排序（Shell Sort）-插入排序的优化版</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">2.冒泡排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">3.快速排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">1.2.3.5.</span> <span class="toc-text">4.归并排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">1.2.3.6.</span> <span class="toc-text">5.堆排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E9%80%92%E6%8E%A8%E5%92%8C%E9%80%92%E5%BD%92"><span class="toc-number">1.2.4.</span> <span class="toc-text">四、递推和递归</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">递归实现深度优先搜索</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E6%8E%92%E5%88%97"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">递归实现排列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E4%BA%8C%E5%88%86%E5%92%8C%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-number">1.2.5.</span> <span class="toc-text">五、二分和前缀和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%88%86"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">二分</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98"><span class="toc-number">1.2.5.1.1.</span> <span class="toc-text">例题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%95%B0%E5%AD%A6"><span class="toc-number">1.2.6.</span> <span class="toc-text">六、数学</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%EF%BC%88%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95%EF%BC%89"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">1.最大公约数（欧几里得算法）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0"><span class="toc-number">1.2.6.2.</span> <span class="toc-text">2.最小公倍数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%88%A4%E6%96%AD%E7%B4%A0%E6%95%B0"><span class="toc-number">1.2.6.3.</span> <span class="toc-text">3.判断素数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.2.6.4.</span> <span class="toc-text">4.进制转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92DP"><span class="toc-number">1.2.7.</span> <span class="toc-text">七、动态规划DP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%EF%BC%88%E6%AF%8F%E4%B8%AA%E7%89%A9%E5%93%81%E4%BB%85%E9%80%89%E6%8B%A9%E4%B8%80%E6%AC%A1%EF%BC%89"><span class="toc-number">1.2.7.1.</span> <span class="toc-text">1.01背包问题（每个物品仅选择一次）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%EF%BC%88%E6%AF%8F%E4%B8%AA%E7%89%A9%E5%93%81%E5%8F%AF%E4%BB%A5%E9%80%89%E5%A4%9A%E6%AC%A1%EF%BC%89"><span class="toc-number">1.2.7.2.</span> <span class="toc-text">2.完全背包（每个物品可以选多次）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%BB%84%E5%90%88%E8%83%8C%E5%8C%85%EF%BC%88%E4%B8%80%E4%BA%9B%E6%97%A0%E9%99%90%E6%AC%A1%E4%B8%80%E4%BA%9B%E6%9C%89%E9%99%90%E6%AC%A1%EF%BC%89"><span class="toc-number">1.2.7.3.</span> <span class="toc-text">3.组合背包（一些无限次一些有限次）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E8%B4%AA%E5%BF%83"><span class="toc-number">1.2.8.</span> <span class="toc-text">八、贪心</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8C%BA%E9%97%B4%E9%80%89%E7%82%B9-%E6%B4%BB%E5%8A%A8%E5%AE%89%E6%8E%92%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.8.1.</span> <span class="toc-text">1.区间选点(活动安排问题)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8C%BA%E9%97%B4%E5%88%86%E7%BB%84"><span class="toc-number">1.2.8.2.</span> <span class="toc-text">2.区间分组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%8C%BA%E9%97%B4%E8%A6%86%E7%9B%96"><span class="toc-number">1.2.8.3.</span> <span class="toc-text">3.区间覆盖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%90%88%E5%B9%B6%E6%9E%9C%E5%AD%90-%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="toc-number">1.2.8.4.</span> <span class="toc-text">4.合并果子(哈夫曼树)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E5%9B%BE%E8%AE%BA"><span class="toc-number">1.2.9.</span> <span class="toc-text">九、图论</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%9C%B4%E7%B4%A0Dijstra%E7%AE%97%E6%B3%95%EF%BC%88%E5%AF%B9%E4%BA%8E%E8%BE%B9%E6%9D%83%E9%9D%9E%E8%B4%9F%E7%9A%84%E5%9B%BE%EF%BC%8C%E6%B1%82%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%EF%BC%89"><span class="toc-number">1.2.9.1.</span> <span class="toc-text">1.朴素Dijstra算法（对于边权非负的图，求单源最短路径）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-BFS%E6%9C%80%E7%9F%AD%E8%B7%AF%E6%A8%A1%E6%9D%BF%EF%BC%88%E6%97%A0%E6%9D%83%E5%9B%BE%EF%BC%89"><span class="toc-number">1.2.9.2.</span> <span class="toc-text">2.BFS最短路模板（无权图）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E9%98%9F%E5%88%97%EF%BC%88%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%EF%BC%89"><span class="toc-number">1.3.1.</span> <span class="toc-text">一、队列（先进先出）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-STL%E4%B8%AD%E7%9A%84queue%EF%BC%88%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97%EF%BC%89"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">1.STL中的queue（双向队列）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%EF%BC%88%E5%BE%AA%E7%8E%AF%E6%95%B0%E7%BB%84%EF%BC%89"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">2.数组实现（循环数组）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">3.链表实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%EF%BC%88%E5%9F%BA%E4%BA%8E%E5%A0%86%E5%AE%9E%E7%8E%B0%EF%BC%89"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">4.优先队列（基于堆实现）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-BFS"><span class="toc-number">1.3.1.5.</span> <span class="toc-text">4.BFS</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%A0%88%EF%BC%88%E5%85%88%E8%BF%9B%E5%90%8E%E5%87%BA%EF%BC%89"><span class="toc-number">1.3.2.</span> <span class="toc-text">二、栈（先进后出）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">1.栈的基本操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AE%9E%E7%8E%B0DFS"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">2.实现DFS</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%9B%BE"><span class="toc-number">1.3.3.</span> <span class="toc-text">三、图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%EF%BC%88%E9%80%82%E7%94%A8%E4%BA%8E%E7%A8%A0%E5%AF%86%E5%9B%BE%EF%BC%89"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">1.邻接矩阵（适用于稠密图）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%82%BB%E6%8E%A5%E8%A1%A8%EF%BC%88%E9%80%82%E7%94%A8%E4%BA%8E%E7%A8%80%E7%96%8F%E5%9B%BE%EF%BC%89"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">2.邻接表（适用于稀疏图）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-%E7%94%A8%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84-%E8%8A%82%E7%9C%81%E7%A9%BA%E9%97%B4"><span class="toc-number">1.3.3.2.1.</span> <span class="toc-text">2.1 用数组模拟链表结构-节省空间</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%AD%E7%BB%83%E9%A2%98"><span class="toc-number">1.4.</span> <span class="toc-text">训练题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-670%E5%8A%A8%E7%89%A9"><span class="toc-number">1.4.1.</span> <span class="toc-text">1. 670动物</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%9F%9F"><span class="toc-number">1.4.2.</span> <span class="toc-text">2. 数组的区域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%B9%B3%E6%96%B9%E7%9F%A9%E9%98%B5I"><span class="toc-number">1.4.3.</span> <span class="toc-text">3.平方矩阵I</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%E4%B8%80%EF%BC%9A%E5%A1%AB%E5%85%85%E7%9F%A9%E9%98%B5"><span class="toc-number">1.4.3.0.0.1.</span> <span class="toc-text">解法一：填充矩阵</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%AF%B9%E8%A7%92%E7%BA%BF"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">解法二：对角线</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0"><span class="toc-number">1.4.4.</span> <span class="toc-text">4.最大公约数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%E4%B8%80%EF%BC%9A%E9%80%90%E4%B8%AA%E5%88%A4%E6%96%AD"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">解法一：逐个判断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%E4%BA%8C%EF%BC%9A%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95%EF%BC%88%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95%EF%BC%89"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">解法二：欧几里得算法（辗转相除法）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%B0%8F%E7%90%83%E5%8F%8D%E5%BC%B9%E9%97%AE%E9%A2%98"><span class="toc-number">1.4.5.</span> <span class="toc-text">5.小球反弹问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%A5%BD%E6%95%B0"><span class="toc-number">1.4.6.</span> <span class="toc-text">6.好数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%E4%B8%80%EF%BC%9A%E6%9E%9A%E4%B8%BE%E6%B3%95"><span class="toc-number">1.4.6.1.</span> <span class="toc-text">解法一：枚举法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%E4%BA%8C%EF%BC%9A%E6%95%B0%E5%AD%97%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">1.4.6.2.</span> <span class="toc-text">解法二：数字动态规划</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-R%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.4.7.</span> <span class="toc-text">7.R格式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%E4%B8%80"><span class="toc-number">1.4.7.1.</span> <span class="toc-text">解法一</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%AE%9D%E7%9F%B3%E7%BB%84%E5%90%88"><span class="toc-number">1.4.8.</span> <span class="toc-text">8.宝石组合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%E4%B8%80%EF%BC%9A%E6%9A%B4%E5%8A%9B"><span class="toc-number">1.4.8.1.</span> <span class="toc-text">解法一：暴力</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E6%95%B0%E7%BB%84%E6%8E%A5%E9%BE%99"><span class="toc-number">1.4.9.</span> <span class="toc-text">9.数组接龙</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E6%8B%94%E6%B2%B3-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">1.4.10.</span> <span class="toc-text">11.拔河(二分查找)</span></a></li></ol></li></ol></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

    <script>
        yiliaConfig.toc = ["隐藏目录", "显示目录", !!"false"];
    </script>



    
<div class="share">
    
        <div class="bdsharebuttonbox">
            <a href="#" class="fa fa-twitter bds_twi" data-cmd="twi" title="分享到推特"></a>
            <a href="#" class="fa fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
            <a href="#" class="fa fa-qq bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
            <a href="#" class="fa fa-files-o bds_copy" data-cmd="copy" title="复制网址"></a>
            <a href="#" class="fa fa fa-envelope-o bds_mail" data-cmd="mail" title="通过邮件分享"></a>
            <a href="#" class="fa fa-weixin bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
            <a href="#" class="fa fa-share-alt bds_more" data-cmd="more"></i></a>
        </div>
        <script>
            window._bd_share_config={
                "common":{"bdSnsKey":{},"bdText":"蓝桥杯准备-C++　| Hexo　","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
        </script>
    

    
</div>







    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2025/07/01/PythonLearn/" title="上一篇: Python基础">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2025/07/01/git-operations/" title="下一篇: Git操作">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2025/07/09/hello-world/">Hello World</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/07/01/PythonLearn/">Python基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/07/01/CppLearn/">蓝桥杯准备-C++</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/07/01/git-operations/">Git操作</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2025 John Doe
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
	<div id="busuanzi_container_site_pv">
	  站点总访问量：<span id="busuanzi_value_site_pv"></span> 次
	</div>
	<div id="busuanzi_container_site_uv">
	  访客数：<span id="busuanzi_value_site_uv"></span> 人
	</div>
	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>